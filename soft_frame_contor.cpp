/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <soft_frame_contor.h>
#include <gr_io_signature.h>
#include <cstdio>
#include <stdexcept>
#include <string.h>
#define VERBOSE 0
inline void
soft_frame_contor::enter_search()
{
  if (VERBOSE)
    fprintf(stderr, "@ enter_search\n");

  d_state = STATE_SYNC_SEARCH;
}
    
inline void
soft_frame_contor::enter_have_sync()
{
  if (VERBOSE)
    fprintf(stderr, "@ enter_have_sync\n");

  d_state = STATE_HAVE_SYNC;
  d_header.reset();
  d_headerbitlen_cnt = 0;
}

inline void
soft_frame_contor::enter_have_header(int d_payload_len)
{
  if (VERBOSE)
    fprintf(stderr, "@ enter_have_header (payload_len = %d)\n", d_payload_len);

  d_state = STATE_HAVE_HEADER;
  d_packetlen = d_payload_len;
  d_packetlen_cnt = 0;
  d_soft_float_counter = 0;
  d_packet_byte = 0;
  d_packet_byte_index = 0;
}

soft_frame_contor_sptr
make_soft_frame_contor(gr_msg_queue_sptr target_queue, short_codec_sptr header_decoder)
{
  return soft_frame_contor_sptr(new soft_frame_contor(target_queue, header_decoder));
}


soft_frame_contor::soft_frame_contor(gr_msg_queue_sptr target_queue, short_codec_sptr header_decoder)
  : gr_sync_block ("soft_frame_contor",
		   gr_make_io_signature2 (2, 2, sizeof(unsigned char), sizeof(float)),
		   gr_make_io_signature (0, 0, 0)),
    d_target_queue(target_queue), d_short_decoder(header_decoder), d_soft_float_counter(0)
{
  enter_search();
}

soft_frame_contor::~soft_frame_contor()
{
}

int
soft_frame_contor::work (int noutput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  const unsigned char *in_hard_and_flag = (const unsigned char *) input_items[0];
  const float         *in_soft          = (const float         *) input_items[1];
  int count=0;
  if (VERBOSE)
    fprintf(stderr,">>> Entering state machine\n");

  while (count < noutput_items){
    switch(d_state) {
      
    case STATE_SYNC_SEARCH:    // Look for flag indicating beginning of pkt
      if (VERBOSE)
        fprintf(stderr,"SYNC Search, noutput=%d\n", noutput_items);
      while (count < noutput_items) {
        if (in_hard_and_flag[count] & 0x2){  // Found it, set up for header decode
            enter_have_sync();
            break;
        }
        count++;
      }
      break;

    case STATE_HAVE_SYNC:
      if (VERBOSE)
          fprintf(stderr,"Header Search bitcnt=%d",d_headerbitlen_cnt);

      while (count < noutput_items) {	// Shift bits one at a time into header
          d_header = d_header << 1;
          d_header.set(0, (bool)(in_hard_and_flag[count++] & 0x1));
          if (++d_headerbitlen_cnt == HEADERBITLEN) {
              if (decode_header()) {
                  get_payload_len(&d_payload_len);
                  enter_have_header(d_payload_len);
                  if (d_packetlen == 0){	    // check for zero-length payload
                    // build a zero-length message
                    // NOTE: passing header field as arg1 is not scalable
	                gr_message_sptr msg = gr_make_message(0, 0, 0, 0);
                    d_target_queue->insert_tail(msg);		// send it
                    msg.reset();  				// free it up
                    enter_search();
                  }
              }
              else
              {
                  fprintf(stderr, "Soft_frame_contor:: Header Decoding Failed\n");
                  enter_search();				// bad header
              }
              break;					// we're in a new state
          }
      }
      break;

    case STATE_HAVE_HEADER:
      if (VERBOSE)
          fprintf(stderr,"Packet Build\n");
      while (count < noutput_items) {   // shift bits into bytes of packet one at a time
        d_packet_byte = (d_packet_byte << 1) | (in_hard_and_flag[count++] & 0x1);
        d_soft_bit_array[d_soft_float_counter++] = in_soft[count -1]; // We are assembling the soft bits
        if (d_packet_byte_index++ == 7) {	  	// byte is full so move to next byte
            d_packet[d_packetlen_cnt++] = d_packet_byte;
            d_packet_byte_index = 0;
            //fprintf(stderr, "d_packetlen_cnt = %d, count = %d \n", d_packetlen_cnt, count);
            if (d_packetlen_cnt == d_packetlen){		// packet is filled, we have assembled complete payload bits and soft bits.
                float* payload_soft_data = new float [d_packetlen * BITS_PER_BYTE];
                memset(payload_soft_data, 0, sizeof(float) * d_packetlen * BITS_PER_BYTE);
                memcpy(payload_soft_data, d_soft_bit_array, sizeof(float) * d_packetlen * BITS_PER_BYTE);
                // build a message
                // NOTE: passing header field as arg1 is not scalable
                gr_message_sptr msg =
                    gr_make_message(0, 0, 0, d_packetlen * sizeof(float) * BITS_PER_BYTE );
                memcpy(msg->msg(), payload_soft_data, d_packetlen * sizeof(float) * BITS_PER_BYTE);
                //reset vectors
                d_target_queue->insert_tail(msg);// send it
                msg.reset();  				// free it up

                delete[] payload_soft_data; // free data in heap
                enter_search();
                break;
            } // end if(d_packetlen_cnt == d_packetlen)
        }// end if (d_packet_byte_index++ == 7)
      }
      break;
      default:
        assert(0);
    } // switch

  }   // while

  return noutput_items;
}

